var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProjects = void 0;
const shared = require("@volar/shared");
const path = require("upath");
const vscode = require("vscode-languageserver");
const project_1 = require("./project");
const utils_1 = require("./utils");
const rootTsConfigNames = ['tsconfig.json', 'jsconfig.json'];
function createProjects(runtimeEnv, languageConfigs, rootPaths, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions, capabilities) {
    let semanticTokensReq = 0;
    let documentUpdatedReq = 0;
    let lastOpenDoc;
    const workspaces = new Map();
    for (const rootPath of rootPaths) {
        workspaces.set(rootPath, createWorkspace(runtimeEnv, languageConfigs, rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions, capabilities));
    }
    documents.onDidOpen((change) => __awaiter(this, void 0, void 0, function* () {
        lastOpenDoc = {
            uri: change.document.uri,
            time: Date.now(),
        };
    }));
    documents.onDidChangeContent((change) => __awaiter(this, void 0, void 0, function* () {
        const req = ++documentUpdatedReq;
        yield waitForOnDidChangeWatchedFiles(change.document.uri);
        for (const workspace of workspaces.values()) {
            const projects = [...workspace.projects.values(), workspace.getInferredProjectDontCreate()].filter(shared.notEmpty);
            for (const project of projects) {
                (yield project).onDocumentUpdated(change.document);
            }
        }
        if (req === documentUpdatedReq) {
            updateDiagnostics(change.document.uri);
        }
    }));
    documents.onDidClose(change => {
        connection.sendDiagnostics({ uri: change.document.uri, diagnostics: [] });
    });
    connection.onDidChangeWatchedFiles(onDidChangeWatchedFiles);
    return {
        workspaces,
        getProject,
        reloadProject,
    };
    function reloadProject(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const [_, workspace] of workspaces) {
                workspace.clearFsCache();
            }
            const configs = [];
            for (const [_, workspace] of workspaces) {
                const config = yield workspace.findMatchConfigs(uri);
                if (config) {
                    configs.push(config);
                }
            }
            onDidChangeWatchedFiles({ changes: configs.map(c => ({ uri: c, type: vscode.FileChangeType.Changed })) });
        });
    }
    function onDidChangeWatchedFiles(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            if (handler.changes.some(change => change.type === vscode.FileChangeType.Created || change.type === vscode.FileChangeType.Deleted)) {
                for (const [_, workspace] of workspaces) {
                    workspace.clearFsCache();
                }
            }
            const tsConfigChanges = [];
            const scriptChanges = [];
            for (const workspace of workspaces.values()) {
                for (const change of handler.changes) {
                    const fileName = shared.uriToFsPath(change.uri);
                    if (rootTsConfigNames.includes(path.basename(fileName)) || workspace.projects.fsPathHas(fileName)) {
                        tsConfigChanges.push(change);
                    }
                    else {
                        scriptChanges.push(change);
                    }
                }
                if (tsConfigChanges.length) {
                    clearDiagnostics();
                    for (const tsConfigChange of tsConfigChanges) {
                        const tsConfig = shared.uriToFsPath(tsConfigChange.uri);
                        if (workspace.projects.fsPathHas(tsConfig)) {
                            workspace.projects.fsPathDelete(tsConfig);
                            (() => __awaiter(this, void 0, void 0, function* () { var _a; return (_a = (yield workspace.projects.fsPathGet(tsConfig))) === null || _a === void 0 ? void 0 : _a.dispose(); }))();
                        }
                        if (tsConfigChange.type !== vscode.FileChangeType.Deleted) {
                            workspace.getProjectByCreate(tsConfig); // create new project
                        }
                    }
                }
                if (scriptChanges.length) {
                    const projects = [...workspace.projects.values(), workspace.getInferredProjectDontCreate()].filter(shared.notEmpty);
                    for (const project of projects) {
                        yield (yield project).onWorkspaceFilesChanged(scriptChanges);
                    }
                }
                onDriveFileUpdated(undefined);
            }
        });
    }
    function onDriveFileUpdated(driveFileName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const req = ++semanticTokensReq;
            yield updateDiagnostics(driveFileName ? shared.fsPathToUri(driveFileName) : undefined);
            if (req === semanticTokensReq) {
                if ((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.semanticTokens) {
                    connection.languages.semanticTokens.refresh();
                }
                if ((_b = options.languageFeatures) === null || _b === void 0 ? void 0 : _b.inlayHints) {
                    connection.languages.semanticTokens.refresh();
                }
            }
        });
    }
    function updateDiagnostics(docUri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = options.languageFeatures) === null || _a === void 0 ? void 0 : _a.diagnostics))
                return;
            const req = ++documentUpdatedReq;
            const delay = yield (lsConfigs === null || lsConfigs === void 0 ? void 0 : lsConfigs.getConfiguration('volar.diagnostics.delay'));
            let lastCheckCancelAt = 0;
            let _isCancel = false;
            const isCancel = () => __awaiter(this, void 0, void 0, function* () {
                if (Date.now() - lastCheckCancelAt >= 5) {
                    yield shared.sleep(5); // wait for onDidChangeContent polling
                    _isCancel = req !== documentUpdatedReq;
                    lastCheckCancelAt = Date.now();
                }
                return _isCancel;
            });
            const changeDocs = docUri ? [(0, utils_1.getDocumentSafely)(documents, docUri)].filter(shared.notEmpty) : [];
            const otherDocs = documents.all().filter(doc => doc.uri !== docUri);
            for (const changeDoc of changeDocs) {
                yield shared.sleep(delay !== null && delay !== void 0 ? delay : 200);
                if (yield isCancel())
                    return;
                yield sendDocumentDiagnostics(changeDoc.uri, isCancel);
            }
            for (const doc of otherDocs) {
                yield shared.sleep(delay !== null && delay !== void 0 ? delay : 200);
                if (yield isCancel())
                    return;
                yield sendDocumentDiagnostics(doc.uri, isCancel);
            }
            function sendDocumentDiagnostics(uri, isCancel) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    const project = (_a = (yield getProject(uri))) === null || _a === void 0 ? void 0 : _a.project;
                    if (!project)
                        return;
                    const languageService = project.getLanguageService();
                    const errors = yield languageService.doValidation(uri, (result) => __awaiter(this, void 0, void 0, function* () {
                        connection.sendDiagnostics({ uri: uri, diagnostics: result });
                    }), isCancel);
                    if (!(yield (isCancel === null || isCancel === void 0 ? void 0 : isCancel()))) {
                        connection.sendDiagnostics({ uri: uri, diagnostics: errors });
                    }
                });
            }
        });
    }
    function getProject(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield waitForOnDidChangeWatchedFiles(uri);
            const fileName = shared.uriToFsPath(uri);
            const rootPaths = [...workspaces.keys()]
                .filter(rootPath => shared.isFileInDir(fileName, rootPath))
                .sort((a, b) => sortPaths(a, b, fileName));
            for (const rootPath of rootPaths) {
                const workspace = workspaces.get(rootPath);
                const project = yield (workspace === null || workspace === void 0 ? void 0 : workspace.getProjectAndTsConfig(uri));
                if (project) {
                    return project;
                }
            }
            if (rootPaths.length) {
                return {
                    tsconfig: undefined,
                    project: yield ((_a = workspaces.get(rootPaths[0])) === null || _a === void 0 ? void 0 : _a.getInferredProject()),
                };
            }
        });
    }
    function waitForOnDidChangeWatchedFiles(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((lastOpenDoc === null || lastOpenDoc === void 0 ? void 0 : lastOpenDoc.uri) === uri) {
                const dt = lastOpenDoc.time + 2000 - Date.now();
                if (dt > 0) {
                    yield shared.sleep(dt);
                }
            }
        });
    }
    function clearDiagnostics() {
        for (const doc of documents.all()) {
            connection.sendDiagnostics({ uri: doc.uri, diagnostics: [] });
        }
    }
}
exports.createProjects = createProjects;
function createWorkspace(runtimeEnv, languageConfigs, rootPath, ts, tsLocalized, options, documents, connection, lsConfigs, getInferredCompilerOptions, capabilities) {
    var _a;
    const rootTsConfigs = ts.sys.readDirectory(rootPath, rootTsConfigNames, undefined, ['**/*']);
    const projects = shared.createPathMap();
    let inferredProject;
    const getRootPath = () => rootPath;
    const _workspaceSys = ts.sys.getCurrentDirectory() === rootPath ? ts.sys : new Proxy(ts.sys, {
        get(target, prop) {
            const fn = target[prop];
            if (typeof fn === 'function') {
                return new Proxy(fn, {
                    apply(target, thisArg, args) {
                        const cwd = process.cwd;
                        process.cwd = getRootPath;
                        const result = target.apply(thisArg, args);
                        process.cwd = cwd;
                        return result;
                    }
                });
            }
            return fn;
        },
    });
    const fileExistsCache = new Map();
    const directoryExistsCache = new Map();
    const sysWithCache = {
        fileExists(path) {
            if (!fileExistsCache.has(path)) {
                fileExistsCache.set(path, ts.sys.fileExists(path));
            }
            return fileExistsCache.get(path);
        },
        directoryExists(path) {
            if (!directoryExistsCache.has(path)) {
                directoryExistsCache.set(path, ts.sys.directoryExists(path));
            }
            return directoryExistsCache.get(path);
        },
    };
    const sys = ((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.didChangeWatchedFiles // don't cache fs result if client not supports file watcher
    )
        ? new Proxy(_workspaceSys, {
            get(target, prop) {
                if (prop in sysWithCache) {
                    return sysWithCache[prop];
                }
                return target[prop];
            },
        })
        : ts.sys;
    return {
        projects,
        findMatchConfigs,
        getProjectAndTsConfig,
        getProjectByCreate,
        getInferredProject,
        getInferredProjectDontCreate: () => inferredProject,
        clearFsCache: () => {
            fileExistsCache.clear();
            directoryExistsCache.clear();
        },
    };
    function getProjectAndTsConfig(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const tsconfig = yield findMatchConfigs(uri);
            if (tsconfig) {
                const project = yield getProjectByCreate(tsconfig);
                return {
                    tsconfig: tsconfig,
                    project,
                };
            }
        });
    }
    function getInferredProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!inferredProject) {
                inferredProject = (0, project_1.createProject)(runtimeEnv, languageConfigs, ts, sys, options, rootPath, yield getInferredCompilerOptions(), tsLocalized, documents, connection, lsConfigs);
            }
            return inferredProject;
        });
    }
    function findMatchConfigs(uri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = shared.uriToFsPath(uri);
            prepareClosestootParsedCommandLine();
            return (_a = yield findDirectIncludeTsconfig()) !== null && _a !== void 0 ? _a : yield findIndirectReferenceTsconfig();
            function prepareClosestootParsedCommandLine() {
                let matches = [];
                for (const rootTsConfig of rootTsConfigs) {
                    if (shared.isFileInDir(shared.uriToFsPath(uri), path.dirname(rootTsConfig))) {
                        matches.push(rootTsConfig);
                    }
                }
                matches = matches.sort((a, b) => sortPaths(fileName, a, b));
                if (matches.length) {
                    getParsedCommandLine(matches[0]);
                }
            }
            function findDirectIncludeTsconfig() {
                return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                    const parsedCommandLine = yield getParsedCommandLine(tsconfig);
                    // use toLowerCase to fix https://github.com/johnsoncodehk/volar/issues/1125
                    const fileNames = new Set(parsedCommandLine.fileNames.map(fileName => fileName.toLowerCase()));
                    return fileNames.has(fileName.toLowerCase());
                }));
            }
            function findIndirectReferenceTsconfig() {
                return findTsconfig((tsconfig) => __awaiter(this, void 0, void 0, function* () {
                    const project = yield projects.fsPathGet(tsconfig);
                    const ls = yield (project === null || project === void 0 ? void 0 : project.getLanguageServiceDontCreate());
                    const validDoc = ls === null || ls === void 0 ? void 0 : ls.__internal__.context.getTsLs().__internal__.getValidTextDocument(uri);
                    return !!validDoc;
                }));
            }
            function findTsconfig(match) {
                return __awaiter(this, void 0, void 0, function* () {
                    const checked = new Set();
                    for (const rootTsConfig of rootTsConfigs.sort((a, b) => sortPaths(fileName, a, b))) {
                        const project = yield projects.fsPathGet(rootTsConfig);
                        if (project) {
                            const chains = yield getReferencesChains(project.getParsedCommandLine(), rootTsConfig, []);
                            for (const chain of chains) {
                                for (let i = chain.length - 1; i >= 0; i--) {
                                    const tsconfig = chain[i];
                                    if (checked.has(tsconfig))
                                        continue;
                                    checked.add(tsconfig);
                                    if (yield match(tsconfig)) {
                                        return tsconfig;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            function getReferencesChains(parsedCommandLine, tsConfig, before) {
                var _a;
                return __awaiter(this, void 0, void 0, function* () {
                    if ((_a = parsedCommandLine.projectReferences) === null || _a === void 0 ? void 0 : _a.length) {
                        const newChains = [];
                        for (const projectReference of parsedCommandLine.projectReferences) {
                            let tsConfigPath = projectReference.path;
                            // fix https://github.com/johnsoncodehk/volar/issues/712
                            if (!sys.fileExists(tsConfigPath) && sys.directoryExists(tsConfigPath)) {
                                const newTsConfigPath = path.join(tsConfigPath, 'tsconfig.json');
                                const newJsConfigPath = path.join(tsConfigPath, 'jsconfig.json');
                                if (sys.fileExists(newTsConfigPath)) {
                                    tsConfigPath = newTsConfigPath;
                                }
                                else if (sys.fileExists(newJsConfigPath)) {
                                    tsConfigPath = newJsConfigPath;
                                }
                            }
                            const beforeIndex = before.indexOf(tsConfigPath); // cycle
                            if (beforeIndex >= 0) {
                                newChains.push(before.slice(0, Math.max(beforeIndex, 1)));
                            }
                            else {
                                const referenceParsedCommandLine = yield getParsedCommandLine(tsConfigPath);
                                for (const chain of yield getReferencesChains(referenceParsedCommandLine, tsConfigPath, [...before, tsConfig])) {
                                    newChains.push(chain);
                                }
                            }
                        }
                        return newChains;
                    }
                    else {
                        return [[...before, tsConfig]];
                    }
                });
            }
            function getParsedCommandLine(tsConfig) {
                return __awaiter(this, void 0, void 0, function* () {
                    const project = yield getProjectByCreate(tsConfig);
                    return project.getParsedCommandLine();
                });
            }
        });
    }
    function getProjectByCreate(tsConfig) {
        let project = projects.fsPathGet(tsConfig);
        if (!project) {
            project = (0, project_1.createProject)(runtimeEnv, languageConfigs, ts, sys, options, path.dirname(tsConfig), tsConfig, tsLocalized, documents, connection, lsConfigs);
            projects.fsPathSet(tsConfig, project);
        }
        return project;
    }
}
function sortPaths(fileName, a, b) {
    const inA = shared.isFileInDir(fileName, path.dirname(a));
    const inB = shared.isFileInDir(fileName, path.dirname(b));
    if (inA !== inB) {
        const aWeight = inA ? 1 : 0;
        const bWeight = inB ? 1 : 0;
        return bWeight - aWeight;
    }
    const aLength = a.split('/').length;
    const bLength = b.split('/').length;
    if (aLength === bLength) {
        const aWeight = path.basename(a) === 'tsconfig.json' ? 1 : 0;
        const bWeight = path.basename(b) === 'tsconfig.json' ? 1 : 0;
        return bWeight - aWeight;
    }
    return bLength - aLength;
}
//# sourceMappingURL=projects.js.map